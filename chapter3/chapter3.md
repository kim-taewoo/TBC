# CHAPTER 3

>"우리는 과거를 알지만 제어할 수는 없다. 우리는 미래를 제어할 수는 있지만 알 수는 없다."  _Claude Shannon

## 3.1 데이터와 자료형 <small>Data and Data Types</small>

- 자료형은 사실 정수형/실수형 두 개만 있다고 생각해도 된다. 
- 얼마나 큰 수를, 혹은 얼마나 작은 수를 사용할 예정이냐에 따라 세부적으로 나뉠 뿐이다.
- 컴퓨터 내부적으로 문자도 정수형으로 저장된다. 

## 3.2 변수와 상수

| 자료형 | 변수 | 리터럴 상수 |
|---|:---:|---|
|int|angel|1004;|

앞에 한정자, 제한자(Qualifier)를 덧붙여 쓸 수 있으며, 변수를 **기호적 상수**(Symbolic constant) 라고 하기도 한다. (예: `const`)

| 한정자, 제한자 | 자료형 | 기호적 상수 | 리터럴 상수 |
|:---|---|:---:|---|
|const|int|angel|1004;|

## 3.3 scanf()
콘솔로 부터 사용자의 입력을 받아 변수에 저장할 때 사용한다. `scanf()` 를 통해 받아온 값을 `&`(ampersand) 를 붙인 변수에 저장한다. (그냥 and 라고 읽는 사람도 있지만 정식명식은 엠펄샌드)

```c
int i = 0;
scanf("%d", &i);
```

::: warning
Visual Studio 에서 `scanf()` 를 쓰면 제대로 컴파일 되지 않는다. 어쩔 수 없이 `#define _CRT_SECURE_NO_WARNINGS` 라는 전처리기를 입력해주거나 VS 설정에 이 전처리 옵션을 따로 지정해 주어야 한다. (옵션 설정시 Release 모드와 Debug 모드 구분 필수)
:::

왜 **&** 를 붙여야 하는가? 

call by reference 개념 공부하자.

## 3.4 간단한 입출력 프로그램 만들기
```c
int i = 0, j = 0;
printf("Input two integers\n");
scanf("%d%d", &i, &j); // 띄어쓰기 없어도 됨에 유의
printf("Your numbers are &d &d\n, i, j);
```

- 터미널에 입력을 할 때, **띄어쓰기나 줄바꿈**으로 입력 값이 구분된다. 

::: tip TODO
`printf()` 와 `scanf()` 에 들어갈 수 있는 모든 형식 지정자 format specifier (예 : %d) 를 찾아보도록 하자.
:::

::: tip
C++ 등 다른 언어에서는 굳이 형식 지정자를 사용하지 않아도 출력할 수 있는 방법이 있다. (iostream)
:::

::: tip
형식지정자(format specififer) 대신 conversion specifier 을 공식명칭으로 쓰기도 한다.
:::

## 3.5 정수와 실수

### 정수 (Integers)
* 음의 정수, 0, 양의 정수
* 내부적으로 2진수 사용
### 실수 (Real numbers)
* 내부적으로 **부동소수점 _(floating point)_** 표현법 사용
* 3.14 = 3.14E0 = 3.14e0 = 0.314E1 = 31.4E-1  (E 는 지수*Exponent* 의 E)
* 내부적으로 2진수 사용

> 소수점이 둥둥 떠다닌다는 뜻의 부동소수점 

| 부호 | 지수 | 분수 | 결과 |
|:---|---|:---:|---|
|+|-1|0.3141592|0.03141592|
|+|2|0.3141592|31.41592|

부호 있는 정수(signed) 일 경우, 맨 앞 한 비트가 0이면 양수, 1이면 음수로 본다. `2의 보수` 표현법이 일반적이다.

부동 소수점 수의 경우, 부호(Sign), 지수(Exponent), 분수(Fraction) 으로 크게 3부분으로 나누어 수를 표현한다. 너무 복잡하니 깊이 파고들 필요 없다. 

32bit Single Precision (반 정밀도 부동소수점 수), 사실 한글로 잘 안 말함
64bit Double Precision (배 정밀도 부동소수점 수)
실수에선 unsigned 가 없어서 맨 앞 비트는 반드시 sign 담당한다.
32에선 1, 8, 23
64에선 1,11, 52
지수부 8비트(11비트) 에서도 맨 앞 비트는 부호를 담당하는 경우가 많기 때문에 
로 sign, exponent, fraction 세부분의 비트를 할당한다.

## 3.6 정수의 오버플로우
`include <limits.h>`\
`signed int i_max = INT_MAX;` 같이 사용하면 자료형 마다의 최대값 혹은 최소값을 알아낼 수 있다. 각 자료형마다의 범위를 벗어나면 오버플로우가 발생한다.

## 3.7 다양한 정수형들
long int 도 int 처럼 4바이트인데, long 이 붙었음에도 같은 4 바이트인 이유는, 예전에는 int 가 2바이트인 경우도 있었기 때문이다. 따라서 현실적으로 **long 은 잘 쓰이지 않고, long long 만 쓸 일이 있다.** long int 가 int 보다 바이트가 크지! 라고 생각했다가 바보될 수 있으니 주의. 마찬가지로, long double 도 그냥 double 과 같은 경우가 있다. 다른 경우도 있지만. (예를 들어 visual studio 에서는 같지만, gcc 에선 다르다.)

## 3.8 8진수와 16진수
8진수 표기법: 앞에 0만 붙이며 된다. 16진수 같은 건 0x, 2진수면 0b 인데 8진수는 앞에 단순히 0만 붙인다는 것 때문에 헷갈릴 수 있음에 주의!

출력할 때 앞에 0x 등을 나오게 하고 싶다면, 형식지정자에 # 을 추가해주면 된다. 대문자로 쓰면 그 x 를 대문자로 출력하게 할 수 있다.

```c
unsigned int hex = 0xffffffff;
printf("%#x", hex) // 0xffffffff
printf("%#X", hex) // 0Xffffffff
```

## 3.9 고정 너비 정수
시스템마다 자료형에서 사용하는 바이트 수가 다르면 이식성에 문제가 생길 수 있다. 그래서 고정 너비 정수 자료형을 사용해서 이식성을 높일 수 있다. (예: `int32_t`)

`#include <inttypes.h>` 를 사용해서 고정 너비 정수형들을 가져올 수 있다. 사실 inttypes.h 는 입출력을 위한 형식 지정자들을 가지고 있는 용도지만, 얘가 고정 너비 정수형들을 가지고 있는 `<stdint.h>` 를 가지고 있기 때문에, 자동으로 사용할 수 있다.

## 3.10 문자형
컴퓨터 내부적으로 문자형도 정수형으로 저장하고 있다. 다시 문자열로 변환할 때는 아스키 테이블을 이용해서 변환한다.
*char* 의 형식지정자는 %c 인데, %hhd (혹은 %hhi) 를 쓰면 해당 *char* 의 아스키코드를 출력할 수 있다.

## 3.11 부동소수점형
significant figure : 유효숫자
exponent : 지수
유효숫자 * 10^지수

m x 10^n  에서, m 을 significand 라고 하고, n 을 exponent 라고 한다. 

믿을 수 있는 숫자를 유효숫자(significand number)라고 한다. 

normalized significand: 1.ㅁㅁㅁ x 2^n (부동소수점에 사용)

4바이트 기준으로, 부동소수점수가 정수형에 비해 표현할 수 있는 범위가 훨씬 넓지만, 유효숫자가 6개 밖에 안된다.

## 3.12 부동소수점형의 한계

- 범위 차이가 너무 많이 나는 숫자들끼리 계산하면 `round-off errors` 가 발생한다. 즉, 작은 범위의 숫자가 무시되어 버린다. 

- 2진법으로 계산되는 부동소수점형의 특성상, 10진수를 정화히 표현 못하는 상황이 많기 때문에 반복된 연산시 오차 발생이 누적되는 때가 있다. 즉, 0.01 을 100번 더해도 1 이 되지 못한다. 

- overflow/underflow

## 3.13 불리언형

메모리에서 배정받는 주소의 가장 작은 단위가 1 바이트이기 때문에 불리언도 1 바이트를 차지한다. 

내부적으로는 false 가 아니면 true 다 라는 식으로 판단한다.